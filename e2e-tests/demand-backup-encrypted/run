#!/bin/bash

set -o errexit
set -o xtrace

test_dir=$(realpath $(dirname $0))
. ${test_dir}/../functions

check_pvc_md5() {
    desc 'check backup file md5sum'
    apply_config "$test_dir/conf/client.yml"
    sleep 10
    bak_client_pod=$(
        kubectl_bin get pods \
            --selector=name=backup-client \
            -o 'jsonpath={.items[].metadata.name}'
    )
    wait_pod $bak_client_pod
    kubectl_bin exec $bak_client_pod -- \
        bash -c "cd /backup; md5sum -c md5sum.txt"
    kubectl_bin delete \
        -f $test_dir/conf/client.yml
}

run_backup() {
    local cluster=$1
    local backup1=$2

    desc 'make backup'
    kubectl_bin apply \
        -f $test_dir/conf/$backup1.yml
    wait_backup $backup1
}

run_recovery_check() {
    local cluster=$1
    local backup1=$2

    desc 'recover backup'
    kubectl_bin apply -f "$test_dir/conf/restore-${backup1}.yaml"
    wait_backup_restore ${backup1}
    kubectl_bin logs job/restore-job-${backup1}-${cluster}
    kubectl_bin delete -f "$test_dir/conf/restore-${backup1}.yaml"
    wait_for_running "$cluster-proxysql" 1
    wait_for_running "$cluster-pxc" 3

    sleep 20
    desc 'check data after backup'
    compare_mysql_cmd "select-1" "SELECT * from myApp.myApp;" "-h $cluster-pxc-0.$cluster-pxc -uroot -proot_password"
    compare_mysql_cmd "select-1" "SELECT * from myApp.myApp;" "-h $cluster-pxc-1.$cluster-pxc -uroot -proot_password"
    compare_mysql_cmd "select-1" "SELECT * from myApp.myApp;" "-h $cluster-pxc-2.$cluster-pxc -uroot -proot_password"

    if [ "$backup1" != "on-demand-backup-minio" ]; then
        desc 'copy backup'
        bash $src_dir/deploy/backup/copy-backup.sh $backup1 $tmp_dir/backup
    fi
}

function jq_filter() {
    local vault_root=$1
    jq -r "[ .[] | .=\"'$vault_root/\"+.+\"'\" ] | join(\", \")"
}

main() {
    create_namespace $namespace
    deploy_operator
    kubectl_bin apply -f $conf_dir/cloud-secret.yml

    vault1="vault-service-1-${RANDOM}"
    start_vault $vault1
    token1=$(jq -r ".root_token" <"$tmp_dir/$vault1")
    ip1="$vault1.$vault1.svc.cluster.local"

    cluster="some-name"
    spinup_pxc "$cluster" "$conf_dir/$cluster.yml"
    keyring_plugin_must_be_in_use "$cluster"
    table_must_be_encrypted "$cluster" "myApp"

    run_backup         "$cluster" "on-demand-backup-pvc"
    run_recovery_check "$cluster" "on-demand-backup-pvc"
    check_pvc_md5
    table_must_be_encrypted "$cluster" "myApp"
    keyring_plugin_must_be_in_use "$cluster"
    
    run_backup         "$cluster" "on-demand-backup-aws-s3"
    run_recovery_check "$cluster" "on-demand-backup-aws-s3"
    table_must_be_encrypted "$cluster" "myApp"
    keyring_plugin_must_be_in_use "$cluster"
    
    mountpt=$(kubectl get -f "$conf_dir/vault-secret.yaml" -o json | grep -oP "secret_mount_point = \w+" | awk -F "=[ ]*" '{print $2}')
    transition_keys=$(kubectl exec --namespace="$vault1" -it pod/$vault1-0 -- sh -c "
        VAULT_TOKEN=$token1 vault kv list -format=json $mountpt/backup/" \
            | jq_filter "$mountpt/backup/")

    vault2="vault-service-2-${RANDOM}"
    start_vault $vault2
    token2=$(jq -r ".root_token" <"$tmp_dir/$vault2")
    ip2="$vault2.$vault2.svc.cluster.local"

    kubectl run -i --tty vault-cp --image=perconalab/vault-cp:latest --restart=Never -- sh -c "
        echo \"
old_url = 'http://$ip1:8200'
old_token = '$token1'
new_url = 'http://$ip2:8200'
new_token = '$token2'
secrets = [ $transition_keys ]
\" > /src/config.py
    python3 /src/vault-cp.py
    "

    run_recovery_check "$cluster" "on-demand-backup-pvc"
    table_must_be_encrypted "$cluster" "myApp"
    keyring_plugin_must_be_in_use "$cluster"

    run_recovery_check "$cluster" "on-demand-backup-aws-s3"
    table_must_be_encrypted "$cluster" "myApp"
    keyring_plugin_must_be_in_use "$cluster"

    for i in $vault1 $vault2; do
        kubectl delete --grace-period=0 --force=true namespace $i
        helm delete --purge $i
    done

    destroy $namespace
}

main
